<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

//concat  产生新数组，不改变原数组
//重新认识：
    /*var arr = [1,2],
            arr1= [3,4],
            a= 'a',
            b= 'b';
    var arr2 = arr.concat(a, b, arr2)*/
//    console.log(arr1);  //[1, 2, "a", "b", 3, 4]   说明连接的不必须是一个数组
//join  将数组中的所有元素链接成一个字符串
    /*var arr = [1,2,3,4]
    var str = arr.join('-')
console.log(str);//1-2-3-4*/
    /*var arr = [1,2,,3,,5];
    var str = arr.join('-')
console.log(str);//1-2--3--5*/

    //push   pop shift unshift
    //改变原数组，push和unshift返回数组的新长度， pop和shift返回删除的元素

    //slice  前取后不取   原数组不变，生成新数组
/*var arr=[1,2,3,4,5]
var arr1 = arr.slice(2)
console.log(arr1);//[3, 4, 5]
console.log(arr);//[1, 2, 3, 4, 5]*/
//splice（start， many,e1, e2...）  既改变原数组又返回了一个新数组
//这里的start指的是将e1,e2...元素放在start做个位置
/*var arr = [1,2,3,4,5,6]
var arr1 = arr.splice(2,0,9,8)
console.log(arr);//[1, 2, 9, 8, 3, 4, 5, 6]
console.log(arr1);//[]*/

//reverse 反转  改变了原数组，不生成新数组
    /*var arr=[1,2,3,4,5,6]
    var arr1 = arr.reverse()
console.log(arr1);//[6, 5, 4, 3, 2, 1]
console.log(arr);//[6, 5, 4, 3, 2, 1]*/

    //sort   排序   改变原数组，不生成新数组
//排序可以根据每一个元素中的各个属性的值来进行排序
//    var arr = [1,7,3,9,2,0,11,43,91]
/*console.log(arr.sort());//[0, 1, 11, 2, 3, 43, 7, 9, 91]  说明这种排序不能直接使用
console.log(arr);//[0, 1, 11, 2, 3, 43, 7, 9, 91]  说明这种排序不能直接使用*/
/*function sortFn(a, b) {

//  return a-b| a>b  //从小到大
    return b-a //从大到小
}
console.log(arr.sort(sortFn));*///[0, 1, 2, 3, 7, 9, 11, 43, 91]

//indexOf(searchElement[, fromIndex]) 根据给定元素查找数组中第一个匹配的元素，返回其索引值。
/*var arr = [1,7,3,9,2,0,11,43,91];
console.log(arr.indexOf(3));//2
console.log(arr.indexOf(3, 5));//-1
//lastIndexOf(searchElement[, fromIndex])   返回的依然是从第一个元素开始算起的位置
console.log(arr.lastIndexOf(91, -1));//8*/



//  arr.forEach(cb(elem, index, arr), thisArg)
// 只是对数组中的每个元素执行一次回调函数，不改变原数组，也不返回什么
// thisArg将作为cb函数的执行上下文类似于callback.call(thisArg, elem, index, array)
// 如果thisArg的值为undefined或null
// 函数的this值取决于当前执行环境是否为严格模式(严格模式下为undefined,非严格模式下为全局对象window)
/*var arr = [1,7,3,9,2,0,11,43,91];
arr.forEach(function(currentValue, index, arr) {
        console.log(currentValue, index, arr);
    console.log(this == window);//true
}, this)*/
//关于forEach 的thisArg  案例：
//得出一个数组中所有元素之和及元素个数
    /*function counter() {
        this.sum = 0;
        this.count = 0;
    }
    counter.prototype.add = function(array) {
        console.log(this.sum == new counter().sum );//这里this指向new出来的对象
        //此时的this要指向counter
        array.forEach(function(elem) {
            this.sum += elem;
            ++this.count;
//            console.log(this == window);//false
            console.log(this );//这里this指向new出来的对象
        },this)
    }
    var obj = new counter()
    obj.add([1,2,3,4])
console.log(obj.sum);//10
console.log(obj.count);//4*/

//深复制
/*function copy(obj) {
    var copy = Object.create(Object.getPrototypeOf(obj));
    var propNames = Object.getOwnPropertyNames(obj);

    propNames.forEach(function(name) {
        var desc = Object.getOwnPropertyDescriptor(obj, name);
        Object.defineProperty(copy, name, desc);
    });

    return copy;
}

var obj1 = { a: 1, b: 2 };
var obj2 = copy(obj1); // obj2 looks like obj1 now
console.log(obj2);
obj2.a = 110
console.log(obj1.a);

//浅复制
    var obj11 = { a: 1, b: 2 };
    var obj22 = obj11;
obj22.a = 110
console.log(obj11);*/

//arr.map(function(currentValue, index, array) {}, thisArg)
//    map()方法返回一个由原数组中的每个元素执行回调函数之后的返回值组成的新数组
//生成新数组，不改变原数组
/*var arr = [1,7,3,9,2,0,11,43,91];
    var arr1 = arr.map(function(elem) {
        return elem*2
    })
console.log(arr1);//[2, 14, 6, 18, 4, 0, 22, 86, 182]
console.log(arr);//[1,7,3,9,2,0,11,43,91]*/
//重新认识： map  不仅可以用在数组上面，也可以用在字符串上
//即使是用在字符串上面，返回的也是一个数组
 /*   var arr11 = Array.prototype.map.call('hello world', function(elem) {
        return elem;
    } )
console.log(arr11);//["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d"]*/
//应用：反转字符串
    /*var str = 'abcdef'
    var newStr = Array.prototype.map.call(str, function(elem) {
        return elem
    }).reverse().join('')
console.log(newStr);//fedcba*/

//filter(function(currentValue, index, arr){},thisArg )使用指定的函数测试所有的元素，并创建一个包含所有通过测试元素的数组
//callback 用来测试数组中的每个元素   返回true表示保留该元素，返回false表示不保留
//filter不会改变原数组，但是会生成一个新数组
    /*var arr = [1,7,3,9,2,0,11,43,91];
    var arr1 = arr.filter(function(elem) {
        return elem >= 10
    })
    console.log(arr1);//[11, 43, 91]*/

//every(function(elem, index, arr){}, thisArg)  测试数组的所有元素是否都通过了指定函数的测试
//every() 的返回值为true/false 布尔值  不会改变原数组
/*var arr = [1,7,3,9,2,0,11,43,91];
    var bool = arr.every(function(elem, index) {
        return elem > 10
    })
console.log(bool);//false*/



//some()   测试数组中的某些元素是否通过了指定函数的测试  与every一样
/*var arr = [1,7,3,9,2,0,11,43,91];
    var bool = arr.some(function(elem) {
        return elem>10
    })
console.log(bool);//true*/


//reduce(function(previousValue, currentValue, index, array) {}[,initialValue] )   接收一个函数作为累加器，数组中的每个值（从左往右）开始合并，最终为一个值
    //previousValue 指的是上一次调用回调返回的值或者是提供的初始值
    //currentValue 指的是数组中当前被处理的元素
    //注意：如果initialValue未提供：那么previousValue等于数组中的第一个值，currentValue等于数组中的第二个值
    //如果提供了initialValue：那么第一个previousValue就等于initialValue，并且currentValue等于数组中的第一个值
    //如果数组未空且没有提供initialValue，则会跑出TypeError
//    提供initialValue
/*var res = [0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){
    return previousValue + currentValue;
});
console.log(res);//10
//    未提供initialValue
var res1 = [0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){
    return previousValue + currentValue;
},10);
console.log(res1);//20
//    应用：1.将数组所有项相加   2.数组扁平化(多维数组合并)
    var flattened = [[0,1], [2,3],[4,5]].reduce(function(a, b) {
        return a.concat(b)
    })
console.log(flattened);//[0, 1, 2, 3, 4, 5]
//reduceRight() 与reduce一样  只不过是从右边往左开始执行的
var a = ["1", "2", "3", "4", "5"];
var left  = a.reduce(function(prev, cur)      { return prev + cur; });
var right = a.reduceRight(function(prev, cur) { return prev + cur; });

console.log(left);  // "12345"
console.log(right); // "54321"*/


//数组泛化
/*Array.prototype.forEach.call("a string", function(chr) {
    console.log(chr);
});*/
/*var str = Array.prototype.filter.call('abcdef', function (c) {return !(/[aeiou]/i).test(c)}).join('');
console.log(str);//bcdf*/

//map与filter的结合
    /*var numbers = [1, 2, 3, 21, 22, 30];
    var doubledEvens = numbers.filter(function(elem) {return elem%2 == 0})*/

    //from()可以将一个类数组对象或可便利对象转换成真正的数组
    //from(arrayLike[,mapFn[,thisArg]])相当于from(arrayLike).map(mapFn, thisArg)
    //mapFn:如果指定了该参数，最后生成的数组会经过该函数的加工处理后再返回
    //thisArg  执行mapFn函数时this的值
// 将类数组对象（arguments）转换成数组
/*(function () {
    var args = Array.from(arguments);
    return args;
})(1, 2, 3);                            // [1, 2, 3]

// 将可迭代对象（Set 对象）转换成数组
Array.from(new Set(["foo", window]));       // ["foo", window]

// Map 对象也可以
var m = new Map([[1, 2], [2, 4], [4, 8]]);
Array.from(m);                          // [[1, 2], [2, 4], [4, 8]]

// 字符串对象既是类数组又是可迭代对象
Array.from("foo");                      // ["f", "o", "o"]

// 使用 map 函数转换数组元素
Array.from([1, 2, 3], x => x + x);      // [2, 4, 6]

// 生成一个数字序列
Array.from({length:5}, (v, k) => k);    // [0, 1, 2, 3, 4]*/


//fill() 方法，可以将一个数组中指定区间的所有元素的值, 都替换成或者说填充成为某个固定的值。
    //arr.fill(value[, start = 0[, end = this.length]])  前取后不取
        /*[1, 2, 3].fill(4)            // [4, 4, 4]
        [1, 2, 3].fill(4, 1)         // [1, 4, 4]
        [1, 2, 3].fill(4, 1, 2)      // [1, 4, 3]
        [1, 2, 3].fill(4, 1, 1)      // [1, 2, 3]
        [1, 2, 3].fill(4, -3, -2)    // [4, 2, 3]
        [1, 2, 3].fill(4, NaN, NaN)  // [1, 2, 3]
        Array(3).fill(4);            // [4, 4, 4]
        [].fill.call({length: 3}, 4) // {0: 4, 1: 4, 2: 4, length: 3}*/

        //arr.find(function(currentValue, index, arr) {}, thisArg)
    //如果数组中某个元素满足测试条件，find()就会返回那个元素的第一个值，如果没有满足条件的元素，则返回undefined

/*function isPrime(element, index, array) {
    var start = 2;
    while (start <= Math.sqrt(element)) {
        if (element % start++ < 1) {
            return false;
        }
    }
    return element > 1;
}

console.log([ 5, 7, 9, 11].find(isPrime));//5*/

//arr.keys()  数组的 keys() 方法返回一个数组索引的迭代器。   索引迭代器
    /*var arr = [1,2,3,4]
    var iterator = arr.keys()
console.log(iterator);
//next() 返回的是index值与是否遍历完成done   只有当value为undefined的时候，done才为false
console.log(iterator.next());//Object {value: 0, done: false}
console.log(iterator.next());//Object {value: 1, done: false}
console.log(iterator.next());//Object {value: 2, done: false}
console.log(iterator.next());//Object {value: 3, done: false}
console.log(iterator.next());//Object {value: undefined, done: true}*/

    //索引迭代器会包含那些没有对应元素的索引
//Object.keys()会返回一个由给定对象的所有可枚举自身属性名组成的数组，数组中属性名的排列书序和使用for-in循环遍历该对象时返回的顺序一致
//
/*var arr = ["a", , "c"];
var sparseKeys = Object.keys(arr);//
var denseKeys = [...arr.keys()];
console.log(sparseKeys); // [0, 2]
console.log(denseKeys);  // [0, 1, 2]*/

//values()  返回一个新的Array Iterator对象，该对象包含数组每个索引的值
/*var arr = ['w', 'y', 'k', 'o', 'p'];
var eArr = arr.values();
console.log(eArr);
//1.使用for...of循环进行迭代
    for(let letter of eArr){
        console.log(letter);
    }
    //2.另一种迭代
console.log(eArr.next().value); // w
console.log(eArr.next().value); // y
console.log(eArr.next().value); // k
console.log(eArr.next().value); // o
console.log(eArr.next().value); // p*/

//entries()  返回一个Array Iterator对象，该对象包含数组中每一个索引的键值对
var arr = ["a", "b", "c"];
var eArr = arr.entries();

console.log(eArr.next().value); // [0, "a"]
console.log(eArr.next().value); // [1, "b"]
console.log(eArr.next().value); // [2, "c"]
console.log(eArr.next().value); // undefined



</script>
</body>
</html>